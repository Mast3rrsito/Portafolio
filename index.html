<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Rubik 3x3</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
</style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>

//////////////////////////
// ESCENA
//////////////////////////

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(6,6,6);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

//////////////////////////
// ILUMINACIÓN PRO
//////////////////////////

scene.add(new THREE.AmbientLight(0xffffff, 0.6));

const light1 = new THREE.DirectionalLight(0xffffff, 1.2);
light1.position.set(5,10,7);
scene.add(light1);

//////////////////////////
// CREAR RUBIK 3x3
//////////////////////////

const rubik = new THREE.Group();
scene.add(rubik);

const pieceSize = 0.95;
const offset = 1;

const material = new THREE.MeshStandardMaterial({
  color: 0x222222,
  metalness: 1,
  roughness: 0.25
});

let pieces = [];

for(let x=-1;x<=1;x++){
  for(let y=-1;y<=1;y++){
    for(let z=-1;z<=1;z++){

      const geo = new THREE.BoxGeometry(pieceSize,pieceSize,pieceSize);
      const cube = new THREE.Mesh(geo, material.clone());

      cube.position.set(x*offset,y*offset,z*offset);

      // bordes
      const edges = new THREE.EdgesGeometry(geo);
      const line = new THREE.LineSegments(
        edges,
        new THREE.LineBasicMaterial({color:0x000000})
      );
      cube.add(line);

      rubik.add(cube);
      pieces.push(cube);
    }
  }
}

//////////////////////////
// SEGUIR RATÓN SUAVE
//////////////////////////

let targetX = 0;
let targetY = 0;

document.addEventListener("mousemove", e => {
  const mouseX = (e.clientX / window.innerWidth) * 2 - 1;
  const mouseY = (e.clientY / window.innerHeight) * 2 - 1;

  targetY = mouseX * 0.6;
  targetX = mouseY * 0.6;
});

//////////////////////////
// ANIMACIÓN GIRO DE CARA
//////////////////////////

let rotating = false;
let rotationGroup = new THREE.Group();

function rotateFace(axis, layer){

  if(rotating) return;
  rotating = true;

  rotationGroup = new THREE.Group();
  rubik.add(rotationGroup);

  pieces.forEach(piece => {
    if(Math.round(piece.position[axis]) === layer){
      rotationGroup.attach(piece);
    }
  });

  let angle = 0;

  function animateRotation(){
    angle += 0.08;

    rotationGroup.rotation[axis] = angle;

    if(angle >= Math.PI/2){
      rotationGroup.rotation[axis] = Math.PI/2;

      while(rotationGroup.children.length > 0){
        rubik.attach(rotationGroup.children[0]);
      }

      rubik.remove(rotationGroup);
      rotating = false;
      return;
    }

    requestAnimationFrame(animateRotation);
  }

  animateRotation();
}

// gira una cara cada 3 segundos
setInterval(()=>{
  const axes = ["x","y","z"];
  const axis = axes[Math.floor(Math.random()*3)];
  const layer = [-1,0,1][Math.floor(Math.random()*3)];
  rotateFace(axis, layer);
},3000);

//////////////////////////
// LOOP PRINCIPAL
//////////////////////////

function animate(){
  requestAnimationFrame(animate);

  rubik.rotation.y += (targetY - rubik.rotation.y) * 0.05;
  rubik.rotation.x += (targetX - rubik.rotation.x) * 0.05;

  renderer.render(scene,camera);
}

animate();

//////////////////////////
// RESPONSIVE
//////////////////////////

window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>

</body>
</html>
