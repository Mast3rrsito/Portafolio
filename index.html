<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Rubik 3D</title>
  <style>
    body { margin: 0; overflow: hidden; background: #0a0a0a; }
  </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

//////////////////////
// ILUMINACIÓN
//////////////////////

const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(5, 5, 5);
scene.add(directionalLight);

//////////////////////
// CUBO NEGRO METÁLICO
//////////////////////

const geometry = new THREE.BoxGeometry(2, 2, 2);

const material = new THREE.MeshStandardMaterial({
  color: 0x111111,
  metalness: 1,
  roughness: 0.2
});

const cube = new THREE.Mesh(geometry, material);
scene.add(cube);

// Líneas tipo Rubik
const edges = new THREE.EdgesGeometry(geometry);
const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
const wireframe = new THREE.LineSegments(edges, lineMaterial);
cube.add(wireframe);

//////////////////////
// SEGUIR EL RATÓN
//////////////////////

let mouseX = 0;
let mouseY = 0;

let targetRotationX = 0;
let targetRotationY = 0;

document.addEventListener("mousemove", (event) => {
  mouseX = (event.clientX / window.innerWidth) * 2 - 1;
  mouseY = (event.clientY / window.innerHeight) * 2 - 1;

  targetRotationY = mouseX * 0.8;
  targetRotationX = mouseY * 0.8;
});

//////////////////////
// ANIMACIÓN SUAVE
//////////////////////

function animate() {
  requestAnimationFrame(animate);

  // Interpolación suave (lerp)
  cube.rotation.y += (targetRotationY - cube.rotation.y) * 0.08;
  cube.rotation.x += (targetRotationX - cube.rotation.x) * 0.08;

  renderer.render(scene, camera);
}

animate();

//////////////////////
// RESPONSIVE
//////////////////////

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
